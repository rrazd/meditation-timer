---
phase: 02-session-controls-and-platform-resilience
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/state.ts
  - index.html
  - src/ui/session-screen.ts
  - src/main.ts
autonomous: true
requirements:
  - TIMER-03
  - TIMER-04

must_haves:
  truths:
    - "User can click Pause during a session and the countdown freezes"
    - "User can click Resume and the countdown continues from the frozen value"
    - "User can click End Session and returns to the setup screen"
    - "Pause button label toggles between 'Pause' and 'Resume' to match current state"
    - "Timer display dims (opacity 0.5) while paused and returns to full opacity on resume"
    - "Starting a second session shows 'Pause' (not 'Resume') on the button"
  artifacts:
    - path: "src/state.ts"
      provides: "AppState with sessionPaused boolean"
      contains: "sessionPaused: boolean"
    - path: "src/ui/session-screen.ts"
      provides: "Pause button toggle and reset function"
      exports: ["initSessionScreen"]
    - path: "index.html"
      provides: "#pause-button element in session screen"
      contains: "id=\"pause-button\""
    - path: "src/main.ts"
      provides: "session:pause and session:resume bus handlers"
      contains: "session:pause"
  key_links:
    - from: "src/ui/session-screen.ts"
      to: "src/event-bus.ts"
      via: "bus.emit('session:pause') and bus.emit('session:resume')"
      pattern: "session:pause|session:resume"
    - from: "src/main.ts"
      to: "src/timer.ts"
      via: "timer.pause() in session:pause handler, timer.resume() in session:resume handler"
      pattern: "timer\\.pause|timer\\.resume"
    - from: "src/main.ts"
      to: "src/state.ts"
      via: "state.sessionPaused = true/false in bus handlers"
      pattern: "sessionPaused"
---

<objective>
Wire pause/resume session controls end-to-end: add the Pause button to the HTML, update state shape, implement button toggle logic in session-screen.ts, and add bus handlers in main.ts that call timer.pause()/timer.resume(). Also update the stop and complete handlers for robustness (reset sessionPaused, add race guard).

Purpose: Deliver TIMER-03 (pause/resume) and TIMER-04 (stop early). The timer Worker already supports pause/resume commands — this plan wires the UI layer to those commands through the event bus.

Output: A session screen with a working Pause/Resume toggle button and a fully wired stop flow that resets all pause state.
</objective>

<execution_context>
@/Users/rrazdan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rrazdan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/state.ts
@src/main.ts
@src/ui/session-screen.ts
@index.html
@src/event-bus.ts
@src/timer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend state, add pause button to HTML</name>
  <files>src/state.ts, index.html</files>
  <action>
    In src/state.ts:
    - Add `sessionPaused: boolean` to the `AppState` interface
    - Add `sessionPaused: false` to the exported `state` object initializer

    In index.html, within the `#session-screen` div, replace the single `#stop-button` with a button group. Place both buttons in a `div` with `style="display: flex; flex-direction: column; align-items: center; gap: 1rem;"`:

    Button 1 — pause button (primary action, accent color):
    ```html
    <button
      id="pause-button"
      aria-label="Pause session"
      style="padding: 0.625rem 2rem; background: transparent; color: var(--color-accent); border: 1px solid var(--color-accent); border-radius: 0.375rem; cursor: pointer; font-size: 0.9rem; min-height: 44px; touch-action: manipulation;"
    >Pause</button>
    ```

    Button 2 — stop button (secondary action, muted — keep all existing inline styles, add `min-height: 44px; touch-action: manipulation;`):
    ```html
    <button
      id="stop-button"
      style="padding: 0.5rem 1.5rem; background: transparent; color: var(--color-text-muted); border: 1px solid var(--color-border); border-radius: 0.375rem; cursor: pointer; font-size: 0.85rem; min-height: 44px; touch-action: manipulation;"
    >End Session</button>
    ```

    The `#session-screen` div already has `min-height: 100vh` — leave that unchanged (UX-06 / dvh upgrade is Plan 02-02).
  </action>
  <verify>
    Open index.html in a browser (or run `npm run dev` and visit http://localhost:5173).
    Start a session. Confirm the session screen shows both "Pause" and "End Session" buttons stacked vertically. TypeScript compilation: `npx tsc --noEmit` must pass with no errors.
  </verify>
  <done>
    src/state.ts exports AppState with `sessionPaused: boolean` and state initializes it to `false`. index.html session screen contains `#pause-button` and `#stop-button` in a flex column group. `npx tsc --noEmit` reports zero errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Pause/resume toggle in session-screen.ts and bus wiring in main.ts</name>
  <files>src/ui/session-screen.ts, src/main.ts</files>
  <action>
    In src/ui/session-screen.ts, rewrite `initSessionScreen` to return a `{ reset: () => void }` object (instead of void). The function signature changes to:

    ```typescript
    export function initSessionScreen(onStop: () => void): { reset: () => void }
    ```

    Inside, add:
    - Query `#pause-button` as `HTMLButtonElement`
    - Local `let isPaused = false`
    - `pauseButton.addEventListener('click', ...)` that:
      - If `!isPaused`: sets `isPaused = true`, sets `pauseButton.textContent = 'Resume'`, sets `pauseButton.setAttribute('aria-label', 'Resume session')`, sets `timerDisplay.style.opacity = '0.5'`, emits `bus.emit('session:pause', {})`
      - If `isPaused`: sets `isPaused = false`, sets `pauseButton.textContent = 'Pause'`, sets `pauseButton.setAttribute('aria-label', 'Pause session')`, sets `timerDisplay.style.opacity = '1'`, emits `bus.emit('session:resume', {})`
    - A `reset()` function that sets `isPaused = false`, `pauseButton.textContent = 'Pause'`, `pauseButton.setAttribute('aria-label', 'Pause session')`, `timerDisplay.style.opacity = '1'`
    - Return `{ reset }`

    In src/main.ts, make these targeted additions (preserve all existing code):

    1. Capture the reset function from initSessionScreen:
       Change `initSessionScreen(() => { ... })` to `const { reset: resetSessionScreen } = initSessionScreen(() => { ... })`

    2. In the existing stop handler callback (inside `initSessionScreen`), add `state.sessionPaused = false` before `timer.stop()`:
       ```typescript
       const { reset: resetSessionScreen } = initSessionScreen(() => {
         state.sessionActive = false;
         state.sessionPaused = false;
         timer.stop();
         resetSessionScreen();
         transitionToSetup();
       });
       ```

    3. In the existing `session:start` handler (the `initSetupScreen` callback), add `state.sessionPaused = false`:
       ```typescript
       initSetupScreen((durationMs: number) => {
         state.sessionDurationMs = durationMs;
         state.sessionActive = true;
         state.sessionPaused = false;
         timer.start(durationMs);
         transitionToSession();
       });
       ```

    4. Add two new bus listeners after existing ones:
       ```typescript
       bus.on('session:pause', () => {
         timer.pause();
         state.sessionPaused = true;
         // Wake lock intentionally NOT released on pause — screen stays on
         // so user can see the frozen timer. Browser auto-releases if tab is hidden.
       });

       bus.on('session:resume', () => {
         timer.resume();
         state.sessionPaused = false;
         // Note: acquireWakeLock() called here in Plan 02-02 after wake-lock.ts exists
       });
       ```

    5. Update the existing `session:complete` handler to add a race guard and reset:
       ```typescript
       bus.on('session:complete', () => {
         if (!state.sessionActive) return; // Stop already handled this — ignore
         state.sessionActive = false;
         state.sessionPaused = false;
         resetSessionScreen();
         // Phase 3 will call playChime() here
         transitionToSetup();
       });
       ```

    Do NOT use `initSessionScreen` before it is assigned to `resetSessionScreen`. In TypeScript, restructure so the `const { reset: resetSessionScreen }` declaration is in scope before the `bus.on('session:complete', ...)` listener uses it. Place `initSessionScreen` call before `bus.on('session:complete', ...)`.
  </action>
  <verify>
    Run `npm run dev`. Start a session. Click Pause — confirm countdown freezes, button shows "Resume", timer display dims. Click Resume — countdown continues, button shows "Pause", timer display returns to full opacity. Click End Session — returns to setup screen. Start a second session — button shows "Pause" (not stale "Resume"). Run `npx tsc --noEmit` — zero errors.
  </verify>
  <done>
    Pause button toggles label and opacity correctly. Timer freezes on pause and continues on resume. Stop returns to setup with button state reset. Second session begins with clean Pause button state. Zero TypeScript compilation errors.
  </done>
</task>

</tasks>

<verification>
Full plan verification steps:
1. `npx tsc --noEmit` — must exit 0
2. `npm run build` — must produce dist/ with no errors
3. Manual flow: Start session -> Pause -> Resume -> Pause -> End Session -> Start new session
   - Each state transition must be visually correct
   - Second session must start with "Pause" label (not "Resume")
4. Race guard: Confirm `session:complete` handler has `if (!state.sessionActive) return` guard
</verification>

<success_criteria>
- TIMER-03: User can pause (timer freezes) and resume (timer continues from frozen value) using the Pause/Resume toggle button
- TIMER-04: User can click End Session at any time (including while paused) and return to setup screen with all state reset
- TypeScript compiles without errors
- Pause button state resets correctly between sessions
</success_criteria>

<output>
After completion, create `.planning/phases/02-session-controls-and-platform-resilience/02-01-SUMMARY.md` following the summary template.
</output>
